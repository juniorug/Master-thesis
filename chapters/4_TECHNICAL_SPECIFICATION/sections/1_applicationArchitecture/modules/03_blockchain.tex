\subsection{Blockchain}\label{sec:BlockchainModule}

A blockchain is a peer-to-peer distributed ledger forged by consensus, combined with a system for “smart contracts” and other assistive technologies. Together these can be used to build a new generation of transactional applications that establishes trust, accountability and transparency at their core, while streamlining business processes and legal constraints.

SCM-BP uses Blockchain as a supply chain that track parts and service provenance, ensure authenticity of goods, block counterfeits and reduce conflicts.

To achieve that, Hyperledger Fabric is used. Hyperledger is an open source collaborative effort created to advance cross-industry blockchain technologies. It is a global collaboration, hosted by The Linux Foundation, including leaders in finance, banking, Internet of Things, supply chains, manufacturing and Technology.
Hyperledger Fabric is an enterprise-grade permissioned distributed ledger framework for developing solutions and applications. Its modular and versatile design satisfies a broad range of industry use cases. It offers a unique approach to consensus that enables performance at scale while preserving privacy.

In context of SCM-BP, the Blockchain module consists in a smart contract, chaincode and the ledger. From the application developer’s perspective, a smart contract, together with the ledger, form the heart of a Hyperledger Fabric blockchain system. Whereas a ledger holds facts about the current and historical state of a set of business objects, a smart contract defines the executable logic that generates new facts that are added to the ledger. A chaincode is typically used by administrators to group related smart contracts for deployment, but can also be used for low level system programming of Fabric.

\subsubsection{Smart contract}
Before businesses can transact with each other, they must define a common set of contracts covering common terms, data, rules, concept definitions, and processes. Taken together, these contracts lay out the business model that govern all of the interactions between transacting parties.

A smart contract defines the rules between different organizations in executable code. Applications invoke a smart contract to generate transactions that are recorded on the ledger.

\subsubsection{Chaincode}
Hyperledger Fabric users often use the terms smart contract and chaincode interchangeably. In general, a smart contract defines the transaction logic that controls the lifecycle of a business object contained in the world state. It is then packaged into a chaincode which is then deployed to a blockchain network. Think of smart contracts as governing transactions, whereas chaincode governs how smart contracts are packaged for deployment.

\subsubsection{Ledger}
At the simplest level, a blockchain immutably records transactions which update states in a ledger. A smart contract programmatically accesses two distinct pieces of the ledger – a blockchain, which immutably records the history of all transactions, and a world state that holds a cache of the current value of these states, as it’s the current value of an object that is usually required.

Smart contracts primarily put, get and delete states in the world state, and can also query the immutable blockchain record of transactions.

\begin{itemize}
\item A \textbf{get} typically represents a query to retrieve information about the current state of a business object.
\item A \textbf{put} typically creates a new business object or modifies an existing one in the ledger world state.
\item A \textbf{delete} typically represents the removal of a business object from the current state of the ledger, but not its history.
\end{itemize}

Smart contracts have many APIs available to them. Critically, in all cases, whether transactions create, read, update or delete business objects in the world state, the blockchain contains an immutable record of these changes.

\subsubsection{Implementation Details}\label{sec:Implementation}

The chaincode is written in Golang and provides all contracts needed to proceed traceability in the application. All contracts for use in chaincode must implement the interface \textit{contractapi.ContractInterface}. 

The first step is to create a JSON config file providing all information about these three items. A configuration file includes \textit{assetId}, a list of actors and a list of ordered steps. The chaincode processes this file through  \textit{initLedger} and \textit{createNewAsset} functions. Here follows a template for config file:  

% \begin{minted}{go}
% func main() {
%   chaincode, err := contractapi.NewChaincode(
%     new(SmartContract)
%   )
%   if err != nil {
%     fmt.Printf("Error create chaincode: %s", err.Error())
%     return
%   }
%   if err := chaincode.Start(); err != nil {
%     fmt.Printf("Error starting chaincode: %s", err.Error())
%   }
% }
% \end{minted}

\begin{minted}{json}
{
   "AssetId":"assetName",
   "Actors":[
      {
         "actorType":"type",
         "aditionalInfo":[
            {
               "key":"value"
            }
         ]
      }
   ],
   "Steps":[
      {
         "step":"stepName",
         "stepOrder":1,
         "actorType":"actorType"
      }
   ]
}
\end{minted}

Front-end WebApp enables a user to define settings through a Configuration Page, adding these to the configuration file, as shown in Figure~\ref{fig:frontend02}.
\textcolor{red}{TODO: ATUALIZAR IMAGEM NA NOVA SEÇÃO, ATUALIZAR REFERENCIA}

%htbp
\begin{figure}[ht]
\begin{center}
  \includegraphics[scale=0.265]{images/frontend02.png}
\caption{SCM Configuration page}
\label{fig:frontend02}
\end{center}
\end{figure}

Assets, asset items, steps and actors are described as \textit{structs}, as follows:

\begin{minted}{go}
type Actor struct {
  ActorId    string  `json:"actorId"`
  ActorType  string  `json:"actorType"`
  ActorName  string  `json:"actorName"`
  Deleted    bool    `json:"deleted"`
  AditionalInfo map[string]string `json:"  aditionalInfo"`
}

type Step struct {
  StepId     string  `json:"stepId"`
  StepName   string  `json:"stepName"`
  StepOrder  uint    `json:"stepOrder"`
  ActorType  string  `json:"actorType"`
  Deleted    bool    `json:"deleted"`
  AditionalInfo map[string]string `json:"  aditionalInfo"`
}

type AssetItem struct {
  AssetItemId   string    `json:"assetItemId"`
  OwnerId       string    `json:"ownerId"`
  StepID        string    `json:"stepID"`
  ParentID      string    `json:"parentID"`
  Children      []string  `json:"children"`;
  ProcessDate   string    `json:"processDate"`
  DeliveryDate  string    `json:"deliveryDate"`
  OrderPrice    string    `json:"orderPrice"`
  ShippingPrice string    `json:"shippingPrice"`
  Status        string    `json:"status"`
  Quantity      string    `json:"quantity"`
  Deleted       bool      `json:"deleted"`
  AditionalInfo map[string]string `json:"  aditionalInfo"`
}

type Asset struct {
  AssetId      string       `json:"assetId"`
  AssetName    string       `json:"assetName"`
  AssetItems   []AssetItem  `json:"assetItems"`
  Actors       []Actor      `json:"actors"`
  Steps        []Step       `json:"steps"`
  Deleted      bool         `json:"deleted"`
  AditionalInfo map[string]string `json:"aditionalInfo"`
}
\end{minted}

There are create methods for each one,  responsible for creating an instance of these \textit{structs} and save the state into the Blockchain. Query methods are responsible for interact with the information of any item in the Blockchain.


The \textit{main} function of chaincode invokes the \textit{initLedger} function, reads the configuration files and raises the platform enabling users to interact with the Blockchain via exposing its API, as follows: 

\begin{minted}{go}
func main() {
  chaincode, err := contractapi.NewChaincode(new(SmartContract))
  if err != nil {
    fmt.Printf("Error create chaincode: %s", err.Error())
    return
  }
  if err := chaincode.Start(); err != nil {
    fmt.Printf("Error starting chaincode: %s", err.Error())
  }
}
\end{minted}

When creating an asset item, an \textit{AssetItemId} is generated. Each entity in the chain will have its unique entity ID and timestamp when it starts processing the transaction. By querying \textit{AssetItemId}, the user can easily track the current transaction information and status. Finally, completed all steps, the Blockchain will update \textit{deliverDate} and mark the status as completed once the last actor (generally the consumer) has received the order. Here follows \textit{CreateAsset} function:

\begin{minted}{go}
func (s *SmartContract) CreateAsset(
  ctx contractapi.TransactionContextInterface, assetId string,
  assetName string, assetItems []AssetItem, actors []Actor,
  steps []Step, aditionalInfo map[string]string) error {
  
  if err != nil {
    return fmt.Errorf(
      "Failed to read the data from world state: %s", err
    )
  }

  if assetJSON != nil {
    return fmt.Errorf("The asset %s already exists", assetID)
  }
  
  asset := Asset {
    AssetId:       assetId,
    AssetName:     assetName,
    AssetItems:    assetItems,
    Actors:        actors,
    Steps:         steps,
    Deleted:       false,
    aditionalInfo: aditionalInfo,
  }
  assetAsBytes, _ := json.Marshal(asset)
  if err != nil {
    return err
  }
  return ctx.GetStub().PutState("ASSET"+assetId,assetAsBytes)
}
\end{minted}

\textit{MoveAssetItem} is the method called to update an asset item when it is moved from a step to another. It updates the \textit{CurrentOwnerId}, the \textit{ProcessDate}, information about prices and many other details of the transactions by the key/value map \textit{  aditionalInfo}. Here follows this fuction:

\begin{minted}{go}
func (s *SmartContract) MoveAssetItem(
  ctx contractapi.TransactionContextInterface, 
  assetItemID string, newAssetItemID string, stepID string, 
  newOwnerID string, orderPrice string, shippingPrice string, 
  status string, quantity string, 
  aditionalInfo map[string]string ) error {
  
  _, err := s.QueryAssetItem(ctx, assetItemID)
  if err != nil {
    return err
  }

  newAssetItem := AssetItem{
    AssetItemID:      newAssetItemID,
    OwnerID:          newOwnerID,
    StepID:           stepID,
    ParentID:         assetItemID,
    ProcessDate:      time.Now().Format("2006-01-02 15:04:05"),
    OrderPrice:       orderPrice,
    ShippingPrice:    shippingPrice,
    Status:           status,
    Quantity:         quantity,
    Deleted:          false,
    AditionalInfoMap: aditionalInfo,
  }

  assetItemAsBytes, err := json.Marshal(newAssetItem)
  if err != nil {
    return err
  }

  return ctx.GetStub().PutState(
    "ASSET_ITEM_"+newAssetItemID, assetItemAsBytes
  )
}
\end{minted}

\textcolor{red}{TODO: UPDATE TRACK-ASSET-ITEM METHOD}

\textit{TrackAssetItem} is the method responsible for track an asset item. It returns the children tree of the given element and its ancestors from the beginning of the Supply chain.

\begin{minted}{go}
func (s *SmartContract) TrackAssetItem(
  ctx contractapi.TransactionContextInterface, 
  assetItemID string) ([]*AssetItem, error) {
  
  assetItem, err := s.QueryAssetItem(ctx, assetItemID)
  log.Print("tracking assetItem id: ", assetItem.AssetItemID)
  if err != nil {
    return nil, fmt.Errorf("Failed from world state. %s", err.Error())
  }

  if assetItem == nil {
    return nil, fmt.Errorf("%s does not exist", assetItemID)
  }

  trackedItems := make([]*AssetItem, 0)
  trackedItems = append(trackedItems, assetItem)
  for {
    currentParentId, err := strconv.Atoi(assetItem.ParentID)
    log.Print("currentParentId: ", currentParentId)
    if currentParentId <= 0 {
      log.Print("oldParentId is equals or less than 0. break it")
    break
    }
    parentAssetItem, err := s.QueryAssetItem(ctx, assetItem.ParentID)
    if err != nil {
      return nil, fmt.Errorf(
        "Failed to read from world state. %s", err.Error()
      )
    }
    newParentId, err := strconv.Atoi(parentAssetItem.ParentID)
    log.Print("newParentId: ", newParentId)
    trackedItems = append(trackedItems, parentAssetItem)
    assetItem = parentAssetItem
  }
  return trackedItems, nil
}
\end{minted}


Figure~\ref{fig:sequenceDiagram} shows the interaction flow from users with Árion platform. Initially, an admin persona creates and configure the SCM, adding information about the steps and the users. After that, the admin can activate this SCM, and from that point, the actors can interact with the SCM to provide information about an asset item and also move this asset item through the supply chain. From that point too, any user can track an asset item to get information about the required good.

%htbp
\begin{figure}[ht]
\begin{center}
  \includegraphics[scale=0.5]{images/SequenceDiagram.png}
\caption{SCM User flow}
\label{fig:sequenceDiagram}
\end{center}
\end{figure}
